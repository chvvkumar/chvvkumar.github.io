<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N.I.N.A. Meridian Flip Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define custom colors/classes for dark theme segments */
        .bg-primary-green\/70 { background-color: rgba(16, 185, 129, 0.7); }
        .bg-wait-orange { color: #f97316; }
        .bg-slew-blue { color: #3b82f6; }
        .bg-downtime-red { color: #ef4444; }
        .text-downtime-red { color: #ef4444; }
        .text-wait-orange { color: #f97316; }
        .text-slew-blue { color: #3b82f6; }
        
        /* Set Inter font */
        html { font-family: 'Inter', sans-serif; }

        /* Input Field Styling */
        input[type="number"] {
            background-color: #374151;
            border-color: #4b5563;
            color: #f3f4f6;
            border-radius: 0.5rem; /* Added rounded corners */
        }

        /* Time Axis Styles (Static and Taller) */
        .time-axis-container {
            position: relative;
            width: 100%;
            height: 280px; 
            margin-top: 1rem;
            overflow: hidden; 
            border: 2px solid #374151; 
            border-radius: 8px;
            background-color: #1f2937; 
            padding: 1rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); /* Added shadow */
            cursor: grab;
        }
        .time-axis-container:active {
            cursor: grabbing;
        }

        .time-axis-line-wrapper {
            position: absolute;
            height: 100%;
            left: 0;
            top: 0;
            width: 100%; 
        }
        .time-axis-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #f87171; 
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* Vertical Indicator Lines (Flip, Meridian, Mount Limit) */
        .flip-line, .meridian-line, .mount-limit-line {
            position: absolute;
            width: 2px;
            height: 80%; 
            top: 10%; 
            transform: translateX(-50%);
            z-index: 10;
            border-radius: 1px;
        }
        .flip-line { background-color: #3b82f6; } /* Blue */
        .meridian-line { background-color: #f59e0b; width: 3px; } /* Yellow/Orange */
        .mount-limit-line { background-color: #f87171; width: 2px; border-left: 2px dashed #f87171; } /* Reddish */


        /* Markers and Labels */
        .time-marker-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            text-align: center;
            width: 100px;
            z-index: 30; 
            line-height: 1.2;
        }

        /* --- STATIC LABELS --- */
        .label-meridian {
            color: #f59e0b;
            font-weight: bold;
            bottom: 100%; /* Default top position for static labels */
            transform: translateX(-50%) translateY(40px);
        }
        
        /* 1. FLIP START LABEL: Halfway between timeline (50%) and flip zone top (10%) = 30% */
        .flip-start-label-main { 
            color: #3b82f6;
            font-weight: bold;
            top: 30%; 
            bottom: auto; /* Important: reset bottom property */
            transform: translateX(-50%) translateY(-50%); 
        }

        /* --- BOTTOM LABELS (Mount Limit, Last Sub Start) --- */
        .label-mount-limit {
            color: #f87171; 
            font-weight: bold;
            top: 100%; /* Low below */
            transform: translateX(-50%) translateY(-40px); 
        }
        
        /* 2. SUB START LABEL (DYNAMIC): Just below the sub box */
        .sub-start-label { 
            color: #4ade80; /* Green for Start */
            font-weight: normal;
            top: 55%; /* Positions labels just below the center line */
            bottom: auto;
            transform: translateX(-50%) translateY(10px); /* Small offset down for clearance */
        }

        /* 3. PBM Meridian Stop Label (NEW: Static at t=0 bottom) */
        .pbm-meridian-stop-label-static {
            color: #f87171; /* Red for Stop */
            font-weight: bold;
            top: 100%; /* Low below, same vertical position as mount limit label */
            transform: translateX(-50%) translateY(-40px);
        }

        /* NEW: Visual marker for actual stop point (t_DowntimeStart) */
        .actual-stop-marker {
            position: absolute;
            width: 1px;
            height: 10px;
            top: 50%;
            transform: translateY(-50%);
            border-left: 1px dashed #f87171; /* Dashed red line */
            z-index: 50; 
        }


        /* Flip Zone Styling */
        .flip-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(59, 130, 246, 0.15); 
            border-left: 1px dashed #3b82f6;
            border-right: 1px dashed #3b82f6;
        }
        .flip-zone-label {
            position: absolute;
            top: 5px; 
            left: 50%;
            transform: translate(-50%, 0);
            width: 100%;
            text-align: center;
            font-size: 0.875rem;
            font-weight: bold;
            color: #60a5fa; 
            white-space: nowrap;
            z-index: 30;
        }

        /* PBM Zone Styling */
        .pbm-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(248, 113, 113, 0.15); /* Reddish shade */
            border-right: 1px solid #f87171; /* Solid line at Meridian start of pause */
            z-index: 5; /* Ensure it is behind the meridian line */
        }
        /* Removed .pbm-zone-label CSS block as the label is no longer used */

        /* Sub Exposure Base Styles */
        .sub-exposure {
            position: absolute;
            height: 20px;
            top: 50%; 
            transform: translateY(-50%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
            transition: left 0.3s ease-out, opacity 0.3s ease-in-out, width 0.1s; 
        }
        /* Specific Styles */
        #last-sub-exposure {
            background-color: rgba(16, 185, 129, 0.9);
            cursor: grab;
            z-index: 40;
            border: 2px solid #a7f3d0;
        }
        .previous-sub {
            background-color: rgba(16, 185, 129, 0.4);
            z-index: 39;
        }

        /* Input Field Styling for vertical stacking */
        .input-card {
            background-color: #1f2937; 
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column; 
            border: 1px solid #374151;
        }
        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #4b5563;
            border-radius: 6px;
            font-size: 1.125rem;
            font-family: monospace;
            text-align: right;
            margin-top: 0.25rem;
            color: #f3f4f6;
            background-color: #374151;
        }
        .input-description {
            color: #9ca3af; 
            font-size: 0.75rem;
            margin-top: 0.5rem;
            height: 1.5rem; 
        }
        /* Responsive Grid for Inputs */
        @media (min-width: 768px) {
            .input-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
        @media (max-width: 767px) {
            .input-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        @media (max-width: 500px) {
             .input-grid {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 p-6 min-h-screen font-sans">

    <div class="max-w-4xl mx-auto w-full">
        <!-- Header -->
        <h1 class="text-3xl font-extrabold mb-8 text-blue-400 text-center">N.I.N.A. Meridian Flip Simulator</h1>
        <p class="text-center text-gray-400 mb-6">Visualize how your sub-exposure duration, flip settings, and mount limits interact near the meridian.</p>

        <!-- Input Parameters (Responsive Grid Layout) -->
        <div class="grid gap-4 mb-8 input-grid">
            <!-- T1 Input: Minutes after meridian -->
            <div class="input-card rounded-xl">
                <label for="t1" class="block text-sm font-medium text-gray-200">Flip Earliest Start (T1)</label>
                <input type="number" id="t1" value="2" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Minutes after meridian when the flip *can* start.</p>
            </div>

            <!-- T2 Input: Max. minutes after meridian -->
            <div class="input-card rounded-xl">
                <label for="t2" class="block text-sm font-medium text-gray-200">Flip Software Deadline (T2)</label>
                <input type="number" id="t2" value="15" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Max minutes after meridian the software will attempt to flip.</p>
            </div>

            <!-- Max. Mount Tracking Past Meridian Input -->
            <div class="input-card rounded-xl">
                <label for="t_mount_limit" class="block text-sm font-medium text-gray-200">Max. Mount Tracking Limit</label>
                <input type="number" id="t_mount_limit" value="20" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Mount tracking past meridian limit.</p>
            </div>
            
             <!-- Exposure Duration Input -->
             <div class="input-card rounded-xl">
                <label for="t_exposure" class="block text-sm font-medium text-gray-200">Sub-exposure Duration</label>
                <input type="number" id="t_exposure" value="420" min="1" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Length of the individual sub-exposure (in seconds).</p>
            </div>

            <!-- Pause Before Meridian Input -->
            <div class="input-card rounded-xl">
                <label for="t_pause" class="block text-sm font-medium text-gray-200">Pause before meridian (PBM)</label>
                <input type="number" id="t_pause" value="0" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Optional: Stops tracking before Meridian (in minutes).</p>
            </div>
        </div>
        
        <!-- Key Timing Events (Static Reference Axis with Draggable Sub) -->
        <h2 class="text-xl font-bold mb-3 mt-8 text-gray-200 border-b border-gray-700 pb-2">Timing Visualization</h2>
        <div id="time-axis-chart" class="time-axis-container">
            <div id="time-axis-wrapper" class="time-axis-line-wrapper">
                 <!-- Time axis elements (lines, labels, subs) are generated here by JavaScript -->
            </div>
        </div>
        <p class="text-sm text-gray-500 text-center mt-3">Click and drag the <strong class="text-green-400">Last Sub</strong> box.</p>


        <!-- Flip Outcome Summary -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-700 mt-8">
            <h2 class="text-2xl font-bold mb-4 text-green-400">Flip Outcome Summary</h2>
            <div id="summary" class="text-gray-200 space-y-2">
                <!-- Summary details rendered here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // --- Drag State Variables ---
        let isDragging = false;
        // Default: 7 minutes, 0 seconds (420 seconds) - This value changes based on the calculated snap or manual drag.
        let t_SubEnd_Manual = 420; 
        let initialScaleFactor = 0;
        let maxTime = 600; 

        // System Constants
        const SYSTEM_CONSTANTS = {
            T_Slew: 45,       // Mount Slew/Flip Time (seconds)
        };
        
        // --- Utility Functions ---

        /**
         * Formats total seconds into [+/-]Xm Ys format, ensuring a sign is always shown for non-zero values.
         * @param {number} totalSeconds - Time in seconds (relative to Meridian).
         * @returns {string} Formatted time string (e.g., "+2m 00s" or "-0m 45s").
         */
        function formatTime(totalSeconds) {
            let sign = '';
            if (totalSeconds > 0) {
                sign = '+'; // Add '+' for positive times
            } else if (totalSeconds < 0) {
                sign = '-'; // Keep '-' for negative times
            }
            
            const absSeconds = Math.abs(totalSeconds);
            const totalMinutes = Math.floor(absSeconds / 60);
            const remainingSeconds = absSeconds % 60;

            const secPart = remainingSeconds.toFixed(0).padStart(2, '0');

            // Always show minutes and seconds for consistent time axis labeling.
            return `${sign}${totalMinutes}m ${secPart}s`; 
        }
        
        /**
         * Renders the static time axis, markers, and the draggable sub chain.
         */
        function renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec, T_Exposure, t_SubChainStart, T_Pause_sec) {
            const axisChart = document.getElementById('time-axis-chart');
            const axisWrapper = document.getElementById('time-axis-wrapper');
            
            if (!axisChart || !axisWrapper) return;

            // 1. Determine Scale and Span
            const inputsMaxTime = Math.max(
                Math.abs(T_Effective_Deadline), 
                Math.abs(T_MountLimit_sec), 
                Math.abs(t_SubChainStart), // Use chain start time for left limit
                T_Pause_sec, // Ensure PBM zone is visible
                300
            ); 
            maxTime = inputsMaxTime + 120; // Add 2 minutes buffer on each side
            
            const timeSpan = maxTime * 2; 
            const containerWidth = axisChart.clientWidth || 800;
            const contentWidth = containerWidth * 0.95; 
            
            initialScaleFactor = contentWidth / timeSpan; // Fixed scale for static axis
            
            // Recenter the content slightly within the container
            axisWrapper.style.width = `${containerWidth}px`; 
            
            // Position of the meridian (t=0)
            const meridianPos = (maxTime * initialScaleFactor); 

            // Helper function to convert time to pixel position
            const timeToPos = (time) => ((time + maxTime) * initialScaleFactor);

            // --- Clear and Redraw Static Elements ---
            axisWrapper.innerHTML = '';
            
            // 2. Draw Red Axis Line
            const axisLine = document.createElement('div');
            axisLine.className = 'time-axis-line';
            axisWrapper.appendChild(axisLine);
            
            // 3. Render PBM Pause Zone
            if (T_Pause_sec > 0) {
                const T_PBM_Deadline = -T_Pause_sec;
                const pbmZoneStartPos = timeToPos(T_PBM_Deadline);
                const pbmZoneEndPos = timeToPos(0);
                const pbmZoneWidth = pbmZoneEndPos - pbmZoneStartPos;

                const pbmZone = document.createElement('div');
                pbmZone.className = 'pbm-zone';
                pbmZone.style.left = `${pbmZoneStartPos}px`;
                pbmZone.style.width = `${pbmZoneWidth}px`;
                
                axisWrapper.appendChild(pbmZone);
            }

            // 4. Render FLIP ZONE
            if (T_Effective_Deadline >= T1_sec) {
                const flipZoneStartPos = timeToPos(T1_sec);
                const flipZoneEndPos = timeToPos(T_Effective_Deadline);
                const flipZoneWidth = flipZoneEndPos - flipZoneStartPos;

                const flipZone = document.createElement('div');
                flipZone.className = 'flip-zone';
                flipZone.style.left = `${flipZoneStartPos}px`;
                flipZone.style.width = `${flipZoneWidth}px`;
                
                // Add label above the zone - Updated to use + signs
                const zoneLabel = document.createElement('span');
                zoneLabel.className = 'flip-zone-label';
                zoneLabel.style.top = '10px'; 
                zoneLabel.innerHTML = `FLIP WINDOW (${formatTime(T1_sec)} to ${formatTime(T_Effective_Deadline)})`;

                flipZone.appendChild(zoneLabel);
                axisWrapper.appendChild(flipZone);
            }
            
            // 5. Draw Vertical Indicator Lines (Lines are drawn over zones)
            
            // Flip Start Line
            const flipLine = document.createElement('div');
            flipLine.className = 'flip-line';
            flipLine.style.left = `${timeToPos(t_FlipStart)}px`;
            axisWrapper.appendChild(flipLine);

            // Meridian Line
            const meridianLine = document.createElement('div');
            meridianLine.className = 'meridian-line';
            meridianLine.style.left = `${meridianPos}px`;
            axisWrapper.appendChild(meridianLine);

            // Mount Limit Line
            const mountLimitLine = document.createElement('div');
            mountLimitLine.className = 'mount-limit-line';
            mountLimitLine.style.left = `${timeToPos(T_MountLimit_sec)}px`;
            axisWrapper.appendChild(mountLimitLine);


            // 6. Marker data points (Labels for vertical lines)
            const timeMarkers = [
                { time: 0, label: 'Meridian', color: 'text-yellow-500', placement: 'label-meridian' },
                { time: T_MountLimit_sec, label: 'Mount Limit', color: 'text-red-400', placement: 'label-mount-limit' }, 
                { time: t_FlipStart, label: 'Flip Starts', color: 'text-blue-400', placement: 'flip-start-label-main' }, 
            ];
            
            timeMarkers.forEach(marker => {
                const markerTime = marker.time;
                const position = timeToPos(markerTime);
                
                // Skip markers that fall outside the main visual area
                if (position < 0 || position > containerWidth) return;
                
                const markerLabel = document.createElement('span');
                
                let labelText = marker.label;
                let placementClass = marker.placement;
                let textColorClass = marker.color;
                
                // Add time coordinate to labels, explicitly formatted with +/- sign
                if (marker.label !== 'Meridian') {
                    labelText += `<br/>(${formatTime(markerTime)})`;
                }

                markerLabel.className = `time-marker-label ${textColorClass} ${placementClass}`;
                markerLabel.style.left = `${position}px`;
                markerLabel.innerHTML = labelText;
                
                axisWrapper.appendChild(markerLabel);
            });
            
            // 7. Dynamic Sub Chain Generation
            const subWidth = T_Exposure * initialScaleFactor;

            // Find the start time of the specific sub that triggers the flip (t_StartLastExp)
            let currentSubEnd = t_StartLastExp;
            
            // Generate previous subs until they fall off the left side of the screen
            let i = 1;
            while (true) {
                const T_PrevSubStart = currentSubEnd - T_Exposure;
                const T_PrevSubEnd = currentSubEnd;
                const prevSubStartPos = timeToPos(T_PrevSubStart);

                if (prevSubStartPos < 0) { // Stop drawing if the sub starts off screen
                    break;
                }
                
                let subElement = document.createElement('div');
                subElement.className = 'sub-exposure previous-sub';
                subElement.style.left = `${prevSubStartPos}px`;
                subElement.style.width = `${subWidth}px`;
                subElement.textContent = `Sub N-${i}`;
                subElement.style.opacity = Math.max(0.1, 1 - (i * 0.2)); // Fade opacity further back
                
                axisWrapper.appendChild(subElement);

                currentSubEnd = T_PrevSubStart;
                i++;
            }

            // 8. Add the Draggable/Last Sub (The triggering sub)
            let lastSubElement = document.createElement('div');
            lastSubElement.id = 'last-sub-exposure';
            lastSubElement.className = 'sub-exposure';
            lastSubElement.style.left = `${timeToPos(t_StartLastExp)}px`;
            lastSubElement.style.width = `${subWidth}px`;
            lastSubElement.textContent = `${formatTime(T_Exposure)} (Last Sub)`; 
            lastSubElement.style.cursor = 'grab'; 

            axisWrapper.appendChild(lastSubElement);
            
            // 9. Add Last Sub Start Label (Always shown, dynamic position)
            const startLabel = document.createElement('span');
            startLabel.className = 'time-marker-label sub-start-label'; 
            startLabel.innerHTML = `Last Sub Start<br/>(${formatTime(t_StartLastExp)})`;
            startLabel.style.left = `${timeToPos(t_StartLastExp)}px`;
            axisWrapper.appendChild(startLabel);
            
            // 10. Add Conditional PBM Tracking Stop Label (Static at t=0 bottom) and actual stop marker
            if (T_Pause_sec > 0) {
                 // Label requested by user: Static at Meridian, bottom, text changed to "Pause Before Meridian"
                 const pbmStopLabel = document.createElement('span');
                 pbmStopLabel.className = 'time-marker-label pbm-meridian-stop-label-static';
                 pbmStopLabel.style.left = `${timeToPos(0)}px`;
                 pbmStopLabel.innerHTML = `Pause Before Meridian`;
                 axisWrapper.appendChild(pbmStopLabel);

                 // Add a visual marker for the actual stop time (t_DowntimeStart)
                 const stopMarker = document.createElement('div');
                 stopMarker.className = 'actual-stop-marker';
                 stopMarker.style.left = `${timeToPos(t_DowntimeStart)}px`;
                 axisWrapper.appendChild(stopMarker);
            }

            // Re-apply drag listeners to the newly created element
            setupDrag();

            // Center the view on the Meridian initially
            axisChart.scrollLeft = meridianPos - (containerWidth / 2);
        }

        // --- Drag Handlers (Simplified and uses new Sub Logic) ---
        let subElement, axisChart;

        function handleMouseDown(e) {
            // Check if the actual last-sub-exposure element was clicked
            if (e.target.id !== 'last-sub-exposure') return;
            e.preventDefault();
            isDragging = true;
            e.target.style.cursor = 'grabbing';
            axisChart.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            const rect = axisChart.getBoundingClientRect();
            // Calculate mouse position relative to the axis chart content
            const mouseX = e.clientX - rect.left + axisChart.scrollLeft;

            const timeSpan = maxTime * 2;
            const containerWidth = axisChart.clientWidth || 800;
            const contentWidth = containerWidth * 0.95;
            const scaleFactor = contentWidth / timeSpan; 

            let T_Exposure = parseFloat(document.getElementById('t_exposure').value) || 1; 

            // Calculate time equivalent of the mouse X position (This is the desired START time)
            let t_cursor_start = (mouseX / scaleFactor) - maxTime;
            
            // Anchor the END of the sub, as this is the trigger point.
            let t_new_end = t_cursor_start + T_Exposure;
            
            t_SubEnd_Manual = t_new_end;
            calculateFlip(false); // Do not reset scale during drag
        }

        function handleMouseUp() {
            isDragging = false;
            // The sub element must be re-fetched as it was replaced in renderTimeAxis
            const currentSubElement = document.getElementById('last-sub-exposure');
            if (currentSubElement) {
                currentSubElement.style.cursor = 'grab';
            }
            axisChart.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            // Ensure final position is calculated and snapped after mouse up
            calculateFlip();
        }

        function setupDrag() {
            axisChart = document.getElementById('time-axis-chart');
            
            if (axisChart) {
                // Ensure handlers are only attached once to the chart container
                if (!axisChart.hasAttribute('data-listeners-attached')) {
                    // Use event delegation for mousedown on the axis wrapper
                    axisChart.addEventListener('mousedown', handleMouseDown);
                    axisChart.setAttribute('data-listeners-attached', 'true');
                }
            }
        }
        
        /**
         * Calculates the total downtime and generates the data points based on manual sub placement.
         * @param {boolean} [resetScale=true] - Recalculate maxTime and scale if true.
         */
        function calculateFlip(resetScale = true) {
            
            // 1. Get User Inputs
            const T1_min = parseFloat(document.getElementById('t1').value) || 0;
            const T2_min = parseFloat(document.getElementById('t2').value) || 0;
            const T_Pause_min = parseFloat(document.getElementById('t_pause').value) || 0;
            const T_MountLimit_min = parseFloat(document.getElementById('t_mount_limit').value) || 0; 
            const T_Exposure = parseFloat(document.getElementById('t_exposure').value) || 1; 
            const summaryElement = document.getElementById('summary');
            
            if (!summaryElement) return;

            // Convert to seconds
            const T1_sec = T1_min * 60;
            const T2_sec_software = T2_min * 60; 
            const T_MountLimit_sec = T_MountLimit_min * 60; 
            const T_Pause_sec = T_Pause_min * 60;
            
            // Set initial drag time if not yet set (on initial load)
            if (t_SubEnd_Manual === 420 && T_Exposure > 0) {
                 t_SubEnd_Manual = T_Exposure; 
            }
            
            const T_Effective_Deadline = Math.min(T2_sec_software, T_MountLimit_sec);

            let t_DowntimeStart = t_SubEnd_Manual; // Sub end time determined by drag/snap
            let scenarioDescription = "";

            // Calculate the start time of the *current* sub-exposure based on the end time
            let t_StartLastExp = t_DowntimeStart - T_Exposure; 
            
            let t_FlipStart = 0;
            let T_Wait = 0;
            
            // --- Core Flip Logic ---

            if (T_Pause_sec > 0) {
                 // SCENARIO 1: Pause Before Meridian (PBM) is active
                const T_PBM_Deadline = -T_Pause_sec;
                
                if (t_DowntimeStart > T_PBM_Deadline) {
                     // The sub sequence would cross the PBM point. Clamped to PBM.
                     t_DowntimeStart = T_PBM_Deadline; 
                     t_StartLastExp = t_DowntimeStart - T_Exposure;
                     scenarioDescription = `<strong>PBM CLAMPED:</strong> Tracking must stop at PBM deadline (${formatTime(T_PBM_Deadline)}).`;
                } else {
                     scenarioDescription = `<strong>PBM SAFE:</strong> Sequence ends before PBM. Tracking stops when sub finishes.`;
                }

                // Flip must still wait for T1
                t_FlipStart = T1_sec; 
                T_Wait = t_FlipStart - t_DowntimeStart;

            } else if (T1_sec < T_Effective_Deadline) { 
                // SCENARIO 2: Flip Window (T1 < Deadline) - Opportunistic Flip

                // Check if the current sub finishes after the T_Effective_Deadline (too late)
                if (t_DowntimeStart > T_Effective_Deadline) {
                    // Sub finished too late. Tracking must stop at T_Effective_Deadline.
                    t_DowntimeStart = T_Effective_Deadline;
                    t_StartLastExp = t_DowntimeStart - T_Exposure;
                    scenarioDescription = `<strong>DEADLINE CROSSED:</strong> Sequence crosses the effective deadline. Flip may fail or is clamped.`;
                }
                
                // Check if the sub finishes within the T1 to Deadline window
                if (t_DowntimeStart >= T1_sec && t_DowntimeStart <= T_Effective_Deadline) {
                    // Opportunistic Flip: Sub finished within the window, flip immediately after sub ends.
                    t_FlipStart = t_DowntimeStart;
                    scenarioDescription = `<strong>OPPORTUNISTIC FLIP:</strong> Sub finishes in the flip window. Flip starts immediately after sub ends.`;
                } else if (t_DowntimeStart < T1_sec) {
                    // Sub finished too early (before T1). Must wait for T1.
                    t_FlipStart = T1_sec;
                    scenarioDescription = `<strong>WAIT FOR T1:</strong> Sub finishes before T1. System waits for T1 to start flip.`;
                } else {
                    // Should be covered by DEADLINE CROSSED, but as a fallback
                    t_FlipStart = T_Effective_Deadline;
                }

                // T_Wait is always the difference between when the flip *starts* and when tracking *stopped*.
                T_Wait = t_FlipStart - t_DowntimeStart;

            } else { 
                // SCENARIO 3: Fixed Time Flip (T1 >= Deadline or T1 = T2)
                
                if (t_DowntimeStart > T1_sec) {
                    // Sub finished too late (past T1 deadline)
                    t_DowntimeStart = T1_sec; 
                    t_StartLastExp = t_DowntimeStart - T_Exposure;
                    scenarioDescription = `<strong>FIXED CLAMPED:</strong> Sub finished late. Tracking must stop at the T1 deadline.`;
                } else {
                    scenarioDescription = `<strong>FIXED SAFE:</strong> Sub finished safely before T1. Tracking stops when sub finishes.`;
                }
                
                t_FlipStart = T1_sec; 
                T_Wait = t_FlipStart - t_DowntimeStart;
            }
            
            // Final calculation for Wait (must be 0 or positive)
            T_Wait = Math.max(0, T_Wait);
            
            // --- Final Calculations and Summary Output ---

            const T_PostFlip = SYSTEM_CONSTANTS.T_Slew;
            const time_meridian_to_resume = t_FlipStart + T_PostFlip; 
            const T_Downtime = T_Wait + T_PostFlip;
            
            // Update global maxTime for rendering/drag limits
            const minTime = Math.min(0, t_StartLastExp, -T_Pause_sec) - 60; // Include PBM start time in minimum calculation
            const maxTimeCalc = Math.max(0, T_MountLimit_sec, time_meridian_to_resume) + 60; 
            maxTime = Math.max(Math.abs(minTime), Math.abs(maxTimeCalc)); 
            
            
            // --- SNAP LOGIC (Handles visual transition and anchoring) ---
            const subElement = document.getElementById('last-sub-exposure');
            if (subElement && !isDragging) {
                const axisChart = document.getElementById('time-axis-chart');
                const containerWidth = axisChart.clientWidth || 800;
                const timeSpan = maxTime * 2; 
                const contentWidth = containerWidth * 0.95;
                const scaleFactor = contentWidth / timeSpan; 
                
                const subStartPos = (t_StartLastExp + maxTime) * scaleFactor;
                
                const currentSubStartPos = parseFloat(subElement.style.left.replace('px', '')) || 0;
                const snapThreshold = 1; 

                // If a change in position is detected, snap the visual element
                if (Math.abs(currentSubStartPos - subStartPos) > snapThreshold) {
                    // To prevent visible jumps, we can quickly hide/show on snap
                    subElement.style.transition = 'none';
                    subElement.style.left = `${subStartPos}px`;
                    subElement.style.width = `${T_Exposure * scaleFactor}px`; // Ensure width update is instant
                    
                    // Re-enable transition for smooth dragging/future snaps
                    setTimeout(() => {
                        if (subElement) subElement.style.transition = 'left 0.3s ease-out, opacity 0.3s ease-in-out, width 0.1s';
                    }, 10); 
                } else {
                    // If no snap, ensure width is correct (e.g., if exposure changed while dragging)
                    subElement.style.width = `${T_Exposure * scaleFactor}px`;
                }
            }
            
            // Update the manual anchor point to match the calculated start time when not dragging
            if (!isDragging) {
                // Ensure the next drag starts from the snapped position's end time
                t_SubEnd_Manual = t_DowntimeStart; 
            }


            // Re-render the UI, passing T_Pause_sec
            renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec, T_Exposure, t_StartLastExp - T_Exposure, T_Pause_sec);


            let summaryHTML = `
                <p><strong>Last Sub Start:</strong> <span class="font-mono text-base text-green-400">${formatTime(t_StartLastExp)}</span></p>
                <p><strong>Tracking Stopped At:</strong> <span class="font-mono text-base text-red-400">${formatTime(t_DowntimeStart)}</span></p>

                <hr class="my-3 border-gray-700">
                
                <p><strong>Effective Flip Deadline:</strong> <span class="font-mono text-base text-yellow-500">${formatTime(T_Effective_Deadline)}</span> (Min of T2: ${formatTime(T2_sec_software)} and Mount Limit: ${formatTime(T_MountLimit_sec)})</p>
                
                <hr class="my-3 border-gray-700">

                <p><strong>Flip Initiated At:</strong> <span class="font-mono text-lg text-blue-400">${formatTime(t_FlipStart)}</span></p>
                <p class="mt-2"><strong><span class="text-wait-orange">Pre-Flip Wait Time:</span></strong> <span class="font-mono text-wait-orange text-lg">${formatTime(T_Wait)}</span></p>
                
                <hr class="my-3 border-gray-700">

                <p class="mt-1 text-sm text-gray-400">Imaging Resumes (Time after meridian): <span class="font-mono">${formatTime(time_meridian_to_resume)}</span></p>
                <p class="mt-1 text-sm text-gray-400">${scenarioDescription}</p>
            `;
            summaryElement.innerHTML = summaryHTML;
        }

        // Initialize the calculation and event listeners on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial value for T_SubEnd_Manual to be T_Exposure (the first sub finishes at t=Exposure)
            t_SubEnd_Manual = parseFloat(document.getElementById('t_exposure').value) || 420;
            setupDrag();
            calculateFlip();
            // Recalculate on resize to maintain responsiveness
            window.addEventListener('resize', calculateFlip); 
        });
    </script>
</body>
</html>
