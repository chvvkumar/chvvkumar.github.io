<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meridian Flip Timeline Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define custom colors/classes for dark theme segments */
        .bg-primary-green\/70 { background-color: rgba(16, 185, 129, 0.7); } /* Green 500 w/ opacity */
        .bg-primary-green\/90 { background-color: rgba(16, 185, 129, 0.9); } /* Green 500 w/ opacity */
        .bg-wait-orange { background-color: #f97316; } /* Orange 600 */
        .bg-slew-blue { background-color: #3b82f6; } /* Blue 500 */
        .bg-downtime-red { background-color: #ef4444; } /* Red 500 */
        .text-downtime-red { color: #ef4444; }
        .text-wait-orange { color: #f97316; }
        .text-slew-blue { color: #3b82f6; }


        /* Custom styles for the timeline */
        .timeline-segment {
            transition: all 0.3s ease-out;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); /* Darker shadow for contrast */
            min-width: 3px; /* Ensure visibility */
            cursor: pointer;
        }
        .timeline-segment:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .tooltip {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            /* Dark theme tooltip background */
            background-color: #1f2937; 
            border: 1px solid #4b5563;
        }
        /* Meridian Line (t=0) - Amber */
        .meridian-line {
            width: 4px;
            height: 100%;
            background-color: #f59e0b; /* Amber 500 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        .meridian-line::after {
            content: 'MERIDIAN (t=0)';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -120%);
            font-size: 0.75rem;
            font-weight: 600;
            color: #f59e0b;
            text-align: center;
            width: 100px;
        }
        /* Timeline Container */
        .timeline-container {
            position: relative;
            height: 300px; 
            display: flex;
            align-items: center;
            overflow-x: auto; /* Allow horizontal scrolling only */
            border: 2px solid #374151; /* Gray 700 border */
            border-radius: 8px;
            padding: 1rem 0;
            background-color: #1f2937; /* Gray 800 background */
        }
        
        /* Input Field Styling for Dark Theme */
        input[type="number"], input[type="range"] {
            background-color: #374151; /* Gray 700 */
            border-color: #4b5563; /* Gray 600 */
            color: #f3f4f6; /* Light text */
        }
        input[type="range"]::-webkit-slider-thumb {
            background: #60a5fa; /* Blue 400 */
        }
        input[type="range"]::-moz-range-thumb {
            background: #60a5fa; /* Blue 400 */
        }

        /* Time Axis Styles (New Feature) */
        .time-axis-container {
            position: relative;
            width: 100%;
            height: 100px; 
            margin-top: 1rem;
            overflow-x: hidden; 
            cursor: grab;
        }
        .time-axis-container:active {
            cursor: grabbing;
        }

        .time-axis-line-wrapper {
            position: absolute;
            height: 100%;
            left: 0;
            top: 0;
        }
        .time-axis-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #f87171; /* Red 400 */
            top: 50%;
            transform: translateY(-50%);
        }
        .time-marker {
            position: absolute;
            width: 2px;
            height: 15px;
            background-color: #f87171;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
        }
        /* Marker Label Placements */
        .time-marker-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            text-align: center;
            width: 100px;
        }
        .label-top {
            bottom: 100%;
            transform: translateX(-50%) translateY(5px);
        }
        .label-bottom {
            top: 100%;
            transform: translateX(-50%) translateY(-5px);
        }

        .meridian-axis-marker {
            background-color: #f59e0b;
            height: 30px;
            width: 3px;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .meridian-axis-marker .time-marker-label {
            color: #f59e0b;
            font-weight: bold;
            bottom: 100%; /* Keep meridian label on top */
            transform: translateX(-50%) translateY(5px);
        }

        .flip-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(59, 130, 246, 0.15); /* Blue 500 with opacity */
            border-left: 1px dashed #3b82f6;
            border-right: 1px dashed #3b82f6;
        }
        /* FIX: Explicit height for the help text container to ensure alignment */
        .input-help-container {
            height: 2rem; /* Sufficient height for two lines of text at 0.75rem font size */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 p-6 min-h-screen font-sans">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-extrabold mb-8 text-blue-400">N.I.N.A. Meridian Flip Simulator</h1>

        <!-- Input Parameters -->
        <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-8">
            <!-- T1 Input -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
                <label for="t1" class="block text-sm font-medium text-gray-400 mb-1">Minutes after meridian (T1)</label>
                <input type="number" id="t1" value="2" min="0" oninput="calculateFlip()"
                       class="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg font-mono">
                <div class="input-help-container">
                    <p class="text-xs text-gray-500 mt-1">Flip earliest start time (min)</p>
                </div>
            </div>

            <!-- T2 Input -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
                <label for="t2" class="block text-sm font-medium text-gray-400 mb-1">Max. minutes after meridian (T2)</label>
                <input type="number" id="t2" value="15" min="0" oninput="calculateFlip()"
                       class="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg font-mono">
                <div class="input-help-container">
                    <p class="text-xs text-gray-500 mt-1">Flip software deadline (min)</p>
                </div>
            </div>

            <!-- Pause Before Meridian Input -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
                <label for="t_pause" class="block text-sm font-medium text-gray-400 mb-1">Pause before meridian</label>
                <input type="number" id="t_pause" value="0" min="0" oninput="calculateFlip()"
                       class="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg font-mono">
                <div class="input-help-container">
                    <p class="text-xs text-gray-500 mt-1">Stops tracking before Meridian (min)</p>
                </div>
            </div>

            <!-- Mount Tracking Limit Input -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
                <label for="t_mount_limit" class="block text-sm font-medium text-gray-400 mb-1">Max. Mount Tracking Past Meridian</label>
                <input type="number" id="t_mount_limit" value="20" min="0" oninput="calculateFlip()"
                       class="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg font-mono">
                <div class="input-help-container">
                    <p class="text-xs text-gray-500 mt-1">Absolute physical/driver limit (min)</p>
                </div>
            </div>
            
             <!-- Exposure Duration Input -->
             <div class="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
                <label for="t_exposure" class="block text-sm font-medium text-gray-400 mb-1">Exposure Duration</label>
                <input type="number" id="t_exposure" value="300" min="1" oninput="calculateFlip()"
                       class="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg font-mono">
                <div class="input-help-container">
                    <p class="text-xs text-gray-500 mt-1">Length of the individual sub-exposure (sec)</p>
                </div>
            </div>
        </div>

        <!-- Timeline Visualization -->
        <h2 class="text-xl font-bold mb-3 text-gray-200">Timeline Visualization (<span class="text-downtime-red">Total Downtime: <span id="total-time-min">0s</span></span>)</h2>
        <div id="timeline-chart" class="timeline-container w-full">
            <!-- Segments and Meridian Line are rendered here by JavaScript -->
        </div>
        <p class="text-xs text-gray-500 text-center mt-2">Timeline is scaled dynamically. Hover over segments for detail. (Scroll horizontally if needed)</p>

        <!-- Key Timing Events (Zoomable Axis) -->
        <h2 class="text-xl font-bold mb-3 mt-8 text-gray-200">Key Timing Events (Zoomable Reference Axis)</h2>
        <div id="time-axis-chart" class="time-axis-container">
            <div id="time-axis-wrapper" class="time-axis-line-wrapper">
                <!-- Time axis line and markers are rendered here by JavaScript -->
            </div>
        </div>
        <p class="text-xs text-gray-500 text-center mt-2">Use scroll wheel to **zoom** and click-and-drag to **pan** this axis.</p>


        <!-- Flip Outcome Summary -->
        <div class="bg-green-900/30 p-6 rounded-lg shadow-xl border border-green-700 mt-8">
            <h2 class="text-xl font-bold mb-4 text-green-400">Flip Outcome Summary</h2>
            <div id="summary" class="text-gray-200 space-y-1">
                <!-- Summary details rendered here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // State variables for Pan and Zoom on the Time Axis
        let axisCurrentScale = 1.0;
        let isDragging = false;
        let startX;
        let startScrollLeft;

        // System Constants (Used for Post-Flip calculation)
        const SYSTEM_CONSTANTS = {
            T_Slew: 45,       // Mount Slew/Flip Time (seconds)
        };
        
        // Fixed pixel width for the main visualization bar chart
        const FIXED_TIMELINE_WIDTH_PX = 2000; 

        /**
         * Converts a time in seconds to a formatted string (e.g., 5m 30s).
         * @param {number} totalSeconds
         * @returns {string}
         */
        function formatTime(totalSeconds) {
            const sign = totalSeconds < 0 ? "-" : "";
            const absSeconds = Math.abs(totalSeconds);
            const minutes = Math.floor(absSeconds / 60);
            const seconds = absSeconds % 60;

            const secPart = seconds.toFixed(0);

            if (minutes > 0) {
                return `${sign}${minutes}m ${secPart.padStart(2, '0')}s`;
            }
            return `${sign}${secPart}s`;
        }
        
        /**
         * Renders the zoomable/pannable time axis below the main timeline.
         */
        function renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec) {
            const axisChart = document.getElementById('time-axis-chart');
            const axisWrapper = document.getElementById('time-axis-wrapper');
            axisWrapper.innerHTML = '<div class="time-axis-line"></div>';

            const containerWidth = axisChart.clientWidth || 800;
            const contentWidthBase = containerWidth * 0.95; 

            // --- Determine Scale and Span for Zoom ---
            const maxTime = Math.max(
                Math.abs(t_DowntimeStart), 
                Math.abs(t_FlipStart), 
                T_Effective_Deadline,
                T_MountLimit_sec, // Include T_MountLimit_sec in the span calculation
                300 // Minimum span of 5 minutes (300s) on either side
            ); 
            
            const timeSpan = maxTime * 2; // Time span from -maxTime to +maxTime
            const baseScaleFactor = contentWidthBase / timeSpan;
            
            // Apply current zoom scale
            const currentScaleFactor = baseScaleFactor * axisCurrentScale;
            const scaledContentWidth = timeSpan * currentScaleFactor;
            
            // Set the wrapper width
            axisWrapper.style.width = `${scaledContentWidth}px`;
            
            // --- Calculate Positions ---
            const contentStart = (maxTime * currentScaleFactor);

            // Position of the meridian (t=0)
            const meridianPos = contentStart; 

            // Helper function to convert time to pixel position
            const timeToPos = (time) => (time + maxTime) * currentScaleFactor;

            // --- Render FLIP ZONE ---
            if (T_Effective_Deadline > T1_sec) {
                const flipZoneStartPos = timeToPos(T1_sec);
                const flipZoneEndPos = timeToPos(T_Effective_Deadline);
                const flipZoneWidth = flipZoneEndPos - flipZoneStartPos;

                const flipZone = document.createElement('div');
                flipZone.className = 'flip-zone';
                flipZone.style.left = `${flipZoneStartPos}px`;
                flipZone.style.width = `${flipZoneWidth}px`;
                
                // Add a label for the zone
                flipZone.innerHTML = `
                    <span class="absolute top-0 mt-2 left-1/2 transform -translate-x-1/2 text-xs font-bold text-blue-300">
                        FLIP ZONE (${formatTime(T1_sec)} to ${formatTime(T_Effective_Deadline)})
                    </span>
                `;

                axisWrapper.appendChild(flipZone);
            }
            
            // Marker data points
            const timeMarkers = [
                // Sub Exposure Markers (Top)
                { time: t_StartLastExp, label: 'Last Sub Start', color: 'text-primary-green/70', special: 'sub-start' },
                { time: t_DowntimeStart, label: 'Last Sub End', color: 'text-red-400', special: 'sub-end' },
                
                // Downtime Markers (Bottom/Alternating)
                { time: t_FlipStart, label: 'Flip Starts', color: 'text-blue-400', special: 'flip' },
                // Mount Limit Marker (Now included)
                { time: T_MountLimit_sec, label: 'Mount Limit', color: 'text-yellow-400', special: 'limit' }, 
            ];

            // Use an index to alternate placement (0 = top, 1 = bottom)
            let placementIndex = 0; 
            
            // 1. Render Meridian Marker
            const meridianMarker = document.createElement('div');
            meridianMarker.className = 'time-marker meridian-axis-marker';
            meridianMarker.style.left = `${meridianPos}px`;
            meridianMarker.innerHTML = `<span class="time-marker-label label-top">Meridian</span>`;
            axisWrapper.appendChild(meridianMarker);
            
            // 2. Render Key Time Markers
            timeMarkers.forEach(marker => {
                const markerTime = marker.time;
                const position = timeToPos(markerTime);
                
                // Skip rendering Flip Starts marker if it's right on the meridian and T1 is 0
                if (Math.abs(markerTime) < 1 && marker.label === 'Flip Starts' && Math.abs(T1_sec) < 1) {
                    return; 
                }

                const markerElement = document.createElement('div');
                markerElement.className = `time-marker ${marker.color.replace('text-', 'bg-')}`;
                markerElement.style.left = `${position}px`;
                
                const markerLabel = document.createElement('span');
                
                // Force sub markers to top, Deadline to bottom, and alternate the rest
                let placementClass;
                if (marker.special === 'sub-start' || marker.special === 'sub-end') {
                    placementClass = 'label-top';
                } else if (marker.special === 'limit') {
                    placementClass = 'label-bottom';
                } else {
                    // Alternate placement for Flip Start and Tracking Stops
                    placementClass = (marker.time < 0) ? 'label-bottom' : 'label-top';
                }
                
                markerLabel.className = `time-marker-label ${marker.color} ${placementClass}`;
                markerLabel.innerHTML = `${marker.label}<br/>(${formatTime(markerTime)})`;
                
                markerElement.appendChild(markerLabel);
                axisWrapper.appendChild(markerElement);

                // Increment index only if we rendered the marker 
                placementIndex++;
            });

            // Center the view on the Meridian initially or after zoom
            const scrollCenterPosition = meridianPos - (containerWidth / 2);
            axisChart.scrollLeft = scrollCenterPosition;
        }


        /**
         * Renders the main non-zoomable, scrollable bar chart visualization.
         */
        function renderTimeline(segments, minTime, totalTimeSpan) {
            const timelineChart = document.getElementById('timeline-chart');
            // Clear chart and add meridian line back
            timelineChart.innerHTML = '<div class="meridian-line"></div>'; 
            
            const containerWidth = timelineChart.clientWidth || 800;
            
            // The scale factor is fixed based on the total time span (in seconds) 
            // and the fixed pixel width defined globally.
            const scaleFactor = FIXED_TIMELINE_WIDTH_PX / totalTimeSpan;
            const scaledContentWidth = FIXED_TIMELINE_WIDTH_PX;
            
            const innerWrapper = document.createElement('div');
            innerWrapper.style.position = 'absolute';
            innerWrapper.style.height = '100%';
            innerWrapper.style.width = `${scaledContentWidth + 100}px`; // Add buffer
            innerWrapper.style.left = '0';
            innerWrapper.style.top = '0';

            const leftPadding = 50; // Fixed padding for visual comfort
            const meridianOffsetFromStart = Math.abs(minTime) * scaleFactor;
            const meridianOffsetPixels = meridianOffsetFromStart + leftPadding;
            
            // 1. Render the segments onto the inner wrapper
            segments.forEach((segment) => {
                const duration = segment.duration;
                const width = Math.max(3, duration * scaleFactor); 
                
                const segmentElement = document.createElement('div');
                // Ensure tailwind classes are correctly applied for styling and hover effects
                segmentElement.className = `timeline-segment ${segment.color} h-12 absolute flex items-center justify-center text-white text-xs whitespace-nowrap px-1 font-semibold`;
                
                const positionFromStartOfSpan = segment.time_start - minTime;
                const positionOffset = positionFromStartOfSpan * scaleFactor + leftPadding;

                segmentElement.style.left = `${positionOffset}px`;
                segmentElement.style.width = `${width}px`;
                segmentElement.style.zIndex = '20'; 

                const timeStartLabel = segment.time_start < 0 ? `${formatTime(segment.time_start)} (Before Meridian)` : `${formatTime(segment.time_start)} (After Meridian)`;
                const timeEndLabel = segment.time_end < 0 ? `${formatTime(segment.time_end)} (Before Meridian)` : `${formatTime(segment.time_end)} (After Meridian)`;

                // Re-added the tooltip structure
                segmentElement.innerHTML = `
                    <span class="text-shadow-sm pointer-events-none">${segment.short_name}</span>
                    <div class="tooltip absolute bottom-full mb-3 p-3 bg-gray-800 text-white rounded-md shadow-2xl text-center text-sm">
                        <p class="font-bold text-lg mb-1">${segment.name}</p>
                        <p>Duration: <span class="font-mono">${formatTime(duration)}</span></p>
                        <p>Starts at: <span class="font-mono">${timeStartLabel}</span></p>
                        <p>Ends at: <span class="font-mono">${timeEndLabel}</span></p>
                    </div>
                `;
                
                innerWrapper.appendChild(segmentElement);
            });
            
            timelineChart.appendChild(innerWrapper);

            // Re-center the meridian line on the inner wrapper's coordinates
            const meridianLine = document.querySelector('.meridian-line');
            meridianLine.style.left = `${meridianOffsetPixels}px`;

            // Calculate the necessary scroll position to center the meridian line
            const scrollCenterPosition = meridianOffsetPixels - (containerWidth / 2);
            timelineChart.scrollLeft = scrollCenterPosition;
        }

        // --- Pan and Zoom Event Handlers for Time Axis ---
        function setupPanZoom() {
            const chart = document.getElementById('time-axis-chart');
            if (!chart) return; // Add check for safety

            // Mouse Down (Start Drag)
            chart.addEventListener('mousedown', (e) => {
                isDragging = true;
                chart.style.cursor = 'grabbing';
                startX = e.pageX - chart.offsetLeft;
                startScrollLeft = chart.scrollLeft;
                e.preventDefault();
            });

            // Mouse Leave/Up (Stop Drag)
            document.addEventListener('mouseup', () => {
                isDragging = false;
                chart.style.cursor = 'grab';
            });

            // Mouse Move (Dragging)
            chart.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const x = e.pageX - chart.offsetLeft;
                const walk = (x - startX) * 1.5; // Pan speed multiplier
                chart.scrollLeft = startScrollLeft - walk;
            });

            // Scroll (Zoom)
            chart.addEventListener('wheel', (e) => {
                e.preventDefault();

                const oldScale = axisCurrentScale;
                const zoomFactor = -e.deltaY * 0.001;
                
                // Calculate new scale, clamping between 0.2 and 10.0
                axisCurrentScale = Math.max(0.2, Math.min(10.0, axisCurrentScale + zoomFactor));
                
                // Get mouse position relative to chart
                const rect = chart.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;

                // Calculate the pixel position on the currently scaled timeline that is under the cursor
                const pointToZoomOn = chart.scrollLeft + mouseX;

                // Recalculate and re-render the timeline
                calculateFlip(false); // Re-render without resetting currentScale

                // Calculate the new scroll position to keep the pointToZoomOn fixed
                const timeAxisWrapper = document.getElementById('time-axis-wrapper');
                const newWidth = timeAxisWrapper ? timeAxisWrapper.scrollWidth : 0;
                
                if (newWidth === 0) return;

                const ratio = newWidth / (newWidth / oldScale * axisCurrentScale);
                const newScrollLeft = pointToZoomOn * ratio - mouseX;

                // Apply the new scroll position
                chart.scrollLeft = newScrollLeft;
            });
        }
        
        /**
         * Calculates the total downtime and generates the timeline data points.
         */
        function calculateFlip(resetScale = true) {
            // Reset axis scale only on input changes, not during zoom
            if (resetScale) {
                axisCurrentScale = 1.0;
            }

            // 1. Get User Inputs (converted to seconds where necessary)
            const t1Element = document.getElementById('t1');
            const t2Element = document.getElementById('t2');
            const tPauseElement = document.getElementById('t_pause');
            const tMountLimitElement = document.getElementById('t_mount_limit');
            const tExposureElement = document.getElementById('t_exposure'); // New exposure input
            const summaryElement = document.getElementById('summary');
            const totalTimeMinElement = document.getElementById('total-time-min');
            
            // Safety checks for critical elements
            if (!t1Element || !t2Element || !tExposureElement || !summaryElement || !totalTimeMinElement) {
                console.error("Critical element missing, stopping calculation.");
                return;
            }


            const T1_min = parseFloat(t1Element.value) || 0;
            const T2_min = parseFloat(t2Element.value) || 0;
            const T_Pause_min = parseFloat(tPauseElement.value) || 0;
            const T_MountLimit_min = parseFloat(tMountLimitElement.value) || 0; 
            const T_Exposure = parseFloat(tExposureElement.value) || 1; // Exposure duration in seconds (must be > 0)

            // Convert to seconds
            const T1_sec = T1_min * 60;
            const T2_sec_software = T2_min * 60; 
            const T_MountLimit_sec = T_MountLimit_min * 60; 
            const T_Pause_sec = T_Pause_min * 60;


            // --- Core Logic ---

            // The effective absolute deadline (Mount Limit or T2)
            const T_Effective_Deadline = Math.min(T2_sec_software, T_MountLimit_sec);

            
            let T_LatestEnd = 0;
            let scenarioDescription = "";

            if (T1_sec < T2_sec_software) {
                // Scenario A: Flip Window (T1 < T2). Flip happens whenever the exposure ends between T1 and T2.
                // The last exposure must START so it ends BEFORE T_Effective_Deadline (the hard stop).
                T_LatestEnd = T_Effective_Deadline; 
                scenarioDescription = `Flip Window (${formatTime(T1_sec)} to ${formatTime(T2_sec_software)}): Last exposure must end before effective deadline.`;
            } else {
                // Scenario B: Fixed Time Flip (T1 = T2). Flip happens precisely at T1.
                // The last exposure must START so it ends BEFORE T1.
                T_LatestEnd = T1_sec;
                scenarioDescription = `Fixed Flip Time (${formatTime(T1_sec)}): Last exposure must end before T1.`;
            }

            // Now, integrate Pause Before Meridian (PBM). If PBM is set, the sequence must stop imaging 
            // at the PBM time, regardless of T1/T2.
            if (T_Pause_sec > 0) {
                // If PBM is set, the sequence must stop imaging at -T_Pause_sec.
                // The latest an exposure can end is at -T_Pause_sec.
                // NOTE: We use T_LatestEnd = Math.min(T_LatestEnd, -T_Pause_sec) to respect the PBM stop time
                // if it's earlier than the deadline, but this simple overwrite works for NINA's PBM design.
                T_LatestEnd = -T_Pause_sec;
                scenarioDescription = `Forced Pause (${formatTime(T_Pause_sec)} before meridian): Last exposure must end before PBM stop time.`;
            }

            // Calculate the actual start time of the last exposure
            const t_StartLastExp = T_LatestEnd - T_Exposure;
            
            // The time tracking actually stops is the end time of the last sub:
            const t_DowntimeStart = T_LatestEnd;

            // --- Determine Flip Start Time (t_FlipStart) and Wait Time (T_Wait) ---
            let t_FlipStart = 0;
            let T_Wait = 0;

            if (T_Pause_sec > 0 || T1_sec >= T2_sec_software) {
                // Case 1: PBM is set OR Fixed Time Flip (T1=T2). Must wait for T1.
                t_FlipStart = T1_sec; 
                T_Wait = t_FlipStart - t_DowntimeStart;

            } else { // T1 < T2 (Flip Window)
                // Case 2: Flip Window. Flip immediately after last exposure ends, as long as it's not before T1.
                t_FlipStart = Math.max(T1_sec, t_DowntimeStart);
                T_Wait = t_FlipStart - t_DowntimeStart;
            }
            
            // Ensure T_Wait is not negative (shouldn't happen with the Math.max, but for safety)
            T_Wait = Math.max(0, T_Wait);
            
            // --- Visualization Segment Generation ---

            const T_PostFlip = SYSTEM_CONSTANTS.T_Slew;
            let current_time = t_FlipStart;
            const segments = [];

            // 0. Initial Tracking (Multiple Sub-exposures for context)
            const numContextSubs = 3; 
            let t_sub_start = t_StartLastExp;

            for(let i = 0; i < numContextSubs; i++) {
                t_sub_start -= T_Exposure;
                segments.push({ 
                    name: `Sub N-${numContextSubs - i}`, 
                    short_name: `Sub N-${numContextSubs - i}`, 
                    duration: T_Exposure, 
                    color: 'bg-primary-green/70', 
                    time_start: t_sub_start,
                    time_end: t_sub_start + T_Exposure
                });
            }

            // Last Sub-exposure (Sub N)
            segments.push({
                name: 'LAST SUB-EXPOSURE (Sub N)', 
                short_name: 'LAST SUB', 
                duration: T_Exposure, 
                color: 'bg-primary-green/90', 
                time_start: t_StartLastExp,
                time_end: t_DowntimeStart
            });


            // 1. Pre-Flip Wait (T_Wait)
            if (T_Wait > 0) {
                segments.push({ 
                    name: 'IDLE WAIT', 
                    short_name: 'WAIT', 
                    duration: T_Wait, 
                    color: T_Pause_min > 0 ? 'bg-downtime-red' : 'bg-wait-orange', 
                    time_start: t_DowntimeStart,
                    time_end: t_FlipStart
                });
            }
            
            // --- Post-Flip Sequence ---

            // 2. Flip Execution (Slew)
            const t_slew_end = current_time + SYSTEM_CONSTANTS.T_Slew;
            segments.push({
                name: 'SLEW/FLIP', 
                short_name: 'FLIP', 
                duration: SYSTEM_CONSTANTS.T_Slew, 
                color: 'bg-slew-blue', 
                time_start: current_time,
                time_end: t_slew_end
            });
            current_time = t_slew_end;

            // 3. Resuming Imaging
            segments.push({
                name: 'IMAGING RESUMES', 
                short_name: 'RESUME', 
                duration: 60, // Arbitrary 60s for visual continuity
                color: 'bg-primary-green/90', 
                time_start: current_time,
                time_end: current_time + 60
            });


            // --- 5. Final Calculations and Summary Output ---
            const T_Downtime = T_Wait + T_PostFlip;
            const time_meridian_to_resume = current_time; 

            // Determine the visualization span
            const minTime = segments.reduce((min, s) => Math.min(min, s.time_start), 0);
            const maxTime = segments.reduce((max, s) => Math.max(max, s.time_end), 0); 
            const totalTimeSpan = maxTime - minTime;


            let summaryHTML = `
                <p><strong>Scenario Status:</strong> <span class="text-blue-400">${scenarioDescription}</span></p>
                <p><strong>Last Sub-exposure Start:</strong> <span class="font-mono text-base text-green-400">${formatTime(t_StartLastExp)}</span></p>
                <p><strong>Last Sub-exposure End:</strong> <span class="font-mono text-base text-green-400">${formatTime(t_DowntimeStart)}</span></p>

                <hr class="my-3 border-gray-700">
                
                <p><strong>Effective Flip Deadline:</strong> <span class="font-mono text-base text-yellow-500">${formatTime(T_Effective_Deadline)}</span> (Min of T2: ${formatTime(T2_sec_software)} and Mount Limit: ${formatTime(T_MountLimit_sec)})</p>
                
                <hr class="my-3 border-gray-700">

                <p><strong>Tracking Stopped At:</strong> <span class="font-mono text-lg text-red-400">${formatTime(t_DowntimeStart)}</span></p>
                <p><strong>Flip Initiated At:</strong> <span class="font-mono text-lg text-blue-400">${formatTime(t_FlipStart)}</span></p>
                
                <hr class="my-3 border-gray-700">

                <p><strong>Pre-Flip Wait Time (T_Wait):</strong> <span class="font-mono text-wait-orange text-lg">${formatTime(T_Wait)}</span></p>
                <p><strong>Post-Flip Recovery (T_PostFlip):</strong> <span class="font-mono text-slew-blue text-lg">${formatTime(T_PostFlip)}</span> (Slew Time Only)</p>
                
                <hr class="my-3 border-gray-700">

                <p class="mt-4 text-xl"><strong>TOTAL DOWNTIME:</strong> <span class="text-downtime-red font-bold font-mono">${formatTime(T_Downtime)}</span></p>
                <p class="mt-1 text-sm text-gray-400">Total time from Meridian (t=0) to Imaging Resumption: <span class="font-mono">${formatTime(time_meridian_to_resume)}</span></p>
            `;
            summaryElement.innerHTML = summaryHTML;
            totalTimeMinElement.textContent = formatTime(T_Downtime);
            
            // --- 6. Render Visualization ---
            renderTimeline(segments, minTime, totalTimeSpan);
            // Pass T1_sec and t_StartLastExp for marker generation
            renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec);
        }

        // Initialize the calculation and event listeners on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Setup Pan/Zoom events for the TIME AXIS CHART
            setupPanZoom();

            calculateFlip();
            // Recalculate on resize to maintain responsiveness
            window.addEventListener('resize', calculateFlip); 
        });
    </script>
</body>
</html>
