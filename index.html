<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N.I.N.A. Meridian Flip Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define custom colors/classes for dark theme segments */
        .bg-primary-green\/70 { background-color: rgba(16, 185, 129, 0.7); }
        .bg-wait-orange { color: #f97316; }
        .bg-slew-blue { color: #3b82f6; }
        .bg-downtime-red { color: #ef4444; }
        .text-downtime-red { color: #ef4444; }
        .text-wait-orange { color: #f97316; }
        .text-slew-blue { color: #3b82f6; }
        
        /* Set Inter font */
        html { font-family: 'Inter', sans-serif; }

        /* Input Field Styling */
        input[type="number"] {
            background-color: #374151;
            border-color: #4b5563;
            color: #f3f4f6;
            border-radius: 0.5rem; /* Added rounded corners */
        }

        /* Canvas Styling for Angular Diagram */
        #meridian-diagram-canvas {
            background-color: #1f2937; /* Dark background matching the time axis */
            border: 2px solid #374151; 
            border-radius: 8px;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            /* Ensure the canvas is responsive */
            width: 100%;
            /* Removed max-width restriction to match the linear axis container width */
        }

        /* Time Axis Styles (Static and Taller) */
        .time-axis-container {
            position: relative;
            width: 100%;
            height: 280px; 
            margin-top: 1rem;
            overflow: hidden; 
            border: 2px solid #374151; 
            border-radius: 8px;
            background-color: #1f2937; 
            padding: 1rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); /* Added shadow */
            cursor: grab;
        }
        .time-axis-container:active {
            cursor: grabbing;
        }

        .time-axis-line-wrapper {
            position: absolute;
            height: 100%;
            left: 0;
            top: 0;
            width: 100%; 
        }
        .time-axis-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #f87171; 
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* Vertical Indicator Lines (Flip, Meridian, Mount Limit) */
        .flip-line, .meridian-line, .mount-limit-line {
            position: absolute;
            width: 2px;
            height: 80%; 
            top: 10%; 
            transform: translateX(-50%);
            z-index: 10;
            border-radius: 1px;
        }
        /* Blue for Flip Start/T2 */
        .flip-line { background-color: #3b82f6; } 
        /* Yellow/Orange for Meridian */
        .meridian-line { background-color: #f59e0b; width: 3px; } 
        /* Reddish for Mount Limit/PBM */
        /* Updated: Mount limit line is now solid (no dashed border) and thicker (3px) to match the change in drawLine logic */
        .mount-limit-line { background-color: #f87171; width: 3px; border-left: none; } 


        /* Markers and Labels */
        .time-marker-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            text-align: center;
            width: 100px;
            z-index: 30; 
            line-height: 1.2;
        }

        /* --- STATIC LABELS --- */
        .label-meridian {
            color: #f59e0b;
            font-weight: bold;
            bottom: 100%; /* Default top position for static labels */
            transform: translateX(-50%) translateY(40px);
        }
        
        /* 1. FLIP START LABEL: Halfway between timeline (50%) and flip zone top (10%) = 30% */
        /* Changed to use blue to match the flip zone */
        .flip-start-label-main { 
            color: #3b82f6; /* Blue to match the line */
            font-weight: bold;
            top: 30%; 
            bottom: auto; /* Important: reset bottom property */
            transform: translateX(-50%) translateY(-50%); 
        }

        /* --- BOTTOM LABELS (Mount Limit, Last Sub Start) --- */
        .label-mount-limit {
            color: #f87171; 
            font-weight: bold;
            top: 100%; /* Low below */
            transform: translateX(-50%) translateY(-40px); 
        }
        
        /* 2. SUB START LABEL (DYNAMIC): Just below the sub box */
        .sub-start-label { 
            color: #4ade80; /* Green for Start */
            font-weight: normal;
            top: 55%; /* Positions labels just below the center line */
            bottom: auto;
            transform: translateX(-50%) translateY(10px); /* Small offset down for clearance */
        }

        /* NEW: Visual marker for actual stop point (t_DowntimeStart) */
        .actual-stop-marker {
            position: absolute;
            width: 1px;
            height: 10px;
            top: 50%;
            transform: translateY(-50%);
            border-left: 1px dashed #f87171; /* Dashed red line */
            z-index: 50; 
        }

        /* Zone Label Styling */
        .zone-label {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            opacity: 0.3;
            pointer-events: none;
            z-index: 3;
            white-space: nowrap;
        }

        /* Flip Zone Styling (Blue) */
        .flip-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(59, 130, 246, 0.15); 
            border-left: 1px dashed #3b82f6;
            border-right: 1px dashed #3b82f6;
        }
        .flip-zone-label {
            position: absolute;
            top: 5px; 
            left: 50%;
            transform: translate(-50%, 0);
            width: 100%;
            text-align: center;
            font-size: 0.875rem;
            font-weight: bold;
            color: #60a5fa; 
            white-space: nowrap;
            z-index: 30;
        }

        /* PBM Zone Styling (Reddish) */
        .pbm-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(248, 113, 113, 0.15); /* Reddish shade */
            border-right: 1px solid #f87171; /* Solid line at Meridian start of pause */
            z-index: 5; /* Ensure it is behind the meridian line */
        }

        /* T1 Wait Zone Styling (Orange) */
        .t1-wait-zone {
            position: absolute;
            height: 80%;
            top: 10%;
            background-color: rgba(251, 146, 60, 0.15); /* Orange shade */
            border-right: 1px solid #f97316; /* Solid line at T1 */
            z-index: 5; /* Ensure it is behind other elements */
        }

        /* Sub Exposure Base Styles */
        .sub-exposure {
            position: absolute;
            height: 20px;
            top: 50%; 
            transform: translateY(-50%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
            transition: left 0.3s ease-out, opacity 0.3s ease-in-out, width 0.1s; 
        }
        /* Specific Styles */
        #last-sub-exposure {
            background-color: rgba(16, 185, 129, 0.9);
            cursor: grab;
            z-index: 40;
            border: 2px solid #a7f3d0;
        }
        .previous-sub {
            background-color: rgba(16, 185, 129, 0.4);
            z-index: 39;
        }

        /* Input Field Styling for vertical stacking */
        .input-card {
            background-color: #1f2937; 
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column; 
            border: 1px solid #374151;
        }
        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #4b5563;
            border-radius: 6px;
            font-size: 1.125rem;
            font-family: monospace;
            text-align: right;
            margin-top: 0.25rem;
            color: #f3f4f6;
            background-color: #374151;
        }
        .input-description {
            color: #9ca3af; 
            font-size: 0.75rem;
            margin-top: 0.5rem;
            height: 1.5rem; 
        }
        /* Responsive Grid for Inputs */
        @media (min-width: 768px) {
            .input-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
        @media (max-width: 767px) {
            .input-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        @media (max-width: 500px) {
             .input-grid {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 p-6 min-h-screen font-sans">

    <div class="max-w-4xl mx-auto w-full">
        <!-- Header -->
        <h1 class="text-3xl font-extrabold mb-2 text-blue-400 text-center">N.I.N.A. Meridian Flip Simulator</h1>
        <p class="text-center text-gray-500 text-sm mb-6">By Kumar Challa</p> <!-- Added Author Name -->
        <p class="text-center text-gray-500 text-sm mb-6">Visualize how your sub-exposure duration, flip settings, and mount limits interact near the meridian.</p>

        <!-- Input Parameters (Responsive Grid Layout) -->
        <div class="grid gap-4 mb-8 input-grid">
            <!-- T1 Input: Minutes after meridian -->
            <div class="input-card rounded-xl">
                <label for="t1" class="block text-sm font-medium text-gray-200">Minutes After Meridian (T1)</label>
                <input type="number" id="t1" value="2" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Minutes after meridian when the flip *can* start.</p>
            </div>

            <!-- T2 Input: Max. minutes after meridian -->
            <div class="input-card rounded-xl">
                <label for="t2" class="block text-sm font-medium text-gray-200">Max. Minutes After Meridian (T2)</label>
                <input type="number" id="t2" value="15" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Max minutes after meridian the software will attempt to flip.</p>
            </div>

            <!-- Max. Mount Tracking Past Meridian Input -->
            <div class="input-card rounded-xl">
                <label for="t_mount_limit" class="block text-sm font-medium text-gray-200">Max. Mount Tracking Limit</label>
                <input type="number" id="t_mount_limit" value="20" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Mount tracking past meridian limit.</p>
            </div>
            
             <!-- Exposure Duration Input -->
             <div class="input-card rounded-xl">
                <label for="t_exposure" class="block text-sm font-medium text-gray-200">Sub-exposure Duration</label>
                <input type="number" id="t_exposure" value="420" min="1" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Length of the individual sub-exposure (in seconds).</p>
            </div>

            <!-- Pause Before Meridian Input -->
            <div class="input-card rounded-xl">
                <label for="t_pause" class="block text-sm font-medium text-gray-200">Pause before meridian (PBM)</label>
                <input type="number" id="t_pause" value="0" min="0" oninput="calculateFlip()" class="input-field rounded-lg">
                <p class="input-description">Optional: Stops tracking before Meridian (in minutes).</p>
            </div>
        </div>
        
        <!-- NEW: Angular Visualization -->
        <h2 class="text-xl font-bold mb-3 mt-8 text-gray-200 border-b border-gray-700 pb-2">Angular Sky Visualization</h2>
        <!-- Removed explicit width attribute. Canvas scales 100% via CSS. -->
        <canvas id="meridian-diagram-canvas" height="350" class="mx-auto block"></canvas>
        <p class="text-sm text-gray-500 text-center mt-3 mb-6">Zenith is the Meridian (straight up). The <strong class="text-blue-400">Calculated Flip Start</strong> line shows when the flip will be initiated.<br/><strong>The angular scale is exaggerated for clarity.</strong></p> <!-- FIXED: Removed ** from the end -->

        <!-- Key Timing Events (Static Reference Axis with Draggable Sub) -->
        <h2 class="text-xl font-bold mb-3 mt-8 text-gray-200 border-b border-gray-700 pb-2">Linear Timing Visualization</h2>
        <div id="time-axis-chart" class="time-axis-container">
            <div id="time-axis-wrapper" class="time-axis-line-wrapper">
                 <!-- Time axis elements (lines, labels, subs) are generated here by JavaScript -->
            </div>
        </div>
        <p class="text-sm text-gray-500 text-center mt-3">Click and drag the <strong class="text-green-400">Last Sub</strong> box.</p>
        
        <!-- Scenario Description Box -->
        <div id="scenario-description" class="text-sm text-gray-300 text-center mt-2 mb-6 p-3 bg-gray-800 rounded-lg border border-gray-700 italic">
            <!-- Scenario description will be populated here -->
        </div>


        <!-- Flip Outcome Summary -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-700 mt-8">
            <h2 class="text-2xl font-bold mb-4 text-green-400">Flip Outcome Summary</h2>
            <p class="text-xs text-gray-500 mb-4 italic">All times are relative to the meridian</p>
            <div id="summary" class="text-gray-200 space-y-2">
                <!-- Summary details rendered here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // --- Drag State Variables ---
        let isDragging = false;
        // Default: 7 minutes, 0 seconds (420 seconds) - This value changes based on the calculated snap or manual drag.
        let t_SubEnd_Manual = 420; 
        let initialScaleFactor = 0;
        let maxTime = 600; 

        // System Constants
        const SYSTEM_CONSTANTS = {
            T_Slew: 45,       // Mount Slew/Flip Time (seconds)
        };
        
        /**
         * Converts time (seconds) to an angle (radians) using a proportional but exaggerated scale.
         * T=0 (Meridian) maps to 90 degrees. T_max_display maps to 20 degrees.
         * T_neg_max_display maps to 160 degrees.
         */
        const convertTimeToAngle = (timeInSeconds, T_neg_max_display, T_pos_max_display) => {
            const meridianAngle = 90; // degrees
            const angularSpan = 70; // 90 - 20 = 70. 90 + 70 = 160.

            let angleDegrees;

            if (timeInSeconds >= 0) {
                // Positive time (West - right side): 90 deg down to 20 deg
                const T_pos = timeInSeconds;
                const timeRatio = Math.min(1, T_pos / T_pos_max_display);
                angleDegrees = meridianAngle - (timeRatio * angularSpan);
            } else {
                // Negative time (East - left side): 90 deg up to 160 deg
                const T_neg = Math.abs(timeInSeconds);
                const timeRatio = Math.min(1, T_neg / T_neg_max_display);
                angleDegrees = meridianAngle + (timeRatio * angularSpan);
            }
            
            // Convert degrees to radians
            return angleDegrees * (Math.PI / 180);
        };

        /**
         * Renders the semi-circular angular diagram.
         */
        function renderAngularDiagram(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, T2_sec_software, T_MountLimit_sec, T_Pause_sec, T_neg_max_display, T_pos_max_display) {
            const canvas = document.getElementById('meridian-diagram-canvas');
            if (!canvas) return;
            
            // Set canvas size for high-res drawing that scales down visually
            // Use clientWidth to match the width of the container/linear axis
            const W = canvas.clientWidth; 
            const H = 350;
            canvas.width = W;
            canvas.height = H;

            const ctx = canvas.getContext('2d');
            
            // Canvas Setup (Dark background)
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, W, H);

            // Center and Radius
            // Adjust Cx for center, and R to fit W
            const Cx = W / 2;
            const Cy = H * 0.95; // Center point is near the bottom center
            const R = Math.min(Cx, H * 0.8) * 0.9; // Maximize radius but keep within height/width
            const HorizonY = Cy;
            
            // Text configuration
            ctx.strokeStyle = '#f3f4f6';
            ctx.lineWidth = 2;
            ctx.font = '14px Inter, sans-serif'; // Default font size
            
            // --- 1. Draw Horizon Line (Base of the Diagram) ---
            ctx.beginPath();
            ctx.moveTo(Cx - R, HorizonY);
            ctx.lineTo(Cx + R, HorizonY);
            ctx.strokeStyle = '#9ca3af'; // Gray horizon line
            ctx.stroke();

            // --- 2. Draw Main Arc (Sky) ---
            ctx.beginPath();
            // Draw the semi-circle from 180 deg (left horizon) to 0 deg (right horizon)
            ctx.arc(Cx, Cy, R, Math.PI, 0); 
            ctx.strokeStyle = '#d1d5db'; // Lighter arc line
            ctx.stroke();

            // Helper function to draw a line from center (Cx, Cy) to (x, y) on the arc
            const drawLine = (timeInSeconds, color, isDashed = false, thickness = 2, lengthFactor = 1.0) => {
                // Use the new proportional conversion function
                const angleRad = convertTimeToAngle(timeInSeconds, T_neg_max_display, T_pos_max_display);
                const r_draw = R * lengthFactor;
                const x = Cx + r_draw * Math.cos(angleRad);
                const y = Cy - r_draw * Math.sin(angleRad); 
                
                ctx.beginPath();
                ctx.moveTo(Cx, Cy);
                ctx.lineTo(x, y);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                
                if (isDashed) {
                    ctx.setLineDash([5, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                return { x, y, angleRad }; // Return endpoint for labeling
            };
            
            // --- 3. Draw Marker Lines (No Labels here) ---

            // A. Meridian (Yellow line, T=0) - Matches linear axis
            drawLine(0, '#f59e0b', false, 3);
            ctx.fillStyle = '#f59e0b';
            ctx.textAlign = 'center';
            ctx.fillText('Meridian', Cx, Cy - R - 5);
            
            // A-1. Calculated Flip Start (BLUE dashed line, t_FlipStart) - REVERTED TO BLUE
            drawLine(t_FlipStart, '#3b82f6', true, 2, 1.0); 
            
            // B. T1 (RED line, T1_sec) - CHANGED TO RED
            if (T1_sec > 0) {
                drawLine(T1_sec, '#ef4444', false, 2);
            }

            // C. T2 (Blue line, T2_sec_software) - Solid (T2 is part of the blue flip window)
            if (T2_sec_software > 0) {
                drawLine(T2_sec_software, '#3b82f6', false, 2);
            }
            
            // D. Mount Limit (Solid Red line, T_MountLimit_sec)
            if (T_MountLimit_sec > 0) {
                drawLine(T_MountLimit_sec, '#f87171', false, 3); 
            }
            
            // E. Pause Before Meridian (PBM) - T_PBM_Deadline (Negative time) - CHANGED TO RED
            if (T_Pause_sec > 0) {
                const T_PBM_Deadline = -T_Pause_sec;
                drawLine(T_PBM_Deadline, '#ef4444', false, 2); 
            }

            // --- 4. Draw East/West Direction Labels (Simplified) ---
            
            const eastLabelX = Cx - (R / 2); 
            const eastLabelY = Cy - 10; 

            const westLabelX = Cx + (R / 2);
            const westLabelY = Cy - 10;
            
            ctx.fillStyle = '#9ca3af';
            ctx.textAlign = 'center';
            // Removed East (Pre-Meridian) -> Pre-Meridian
            ctx.fillText('Pre-Meridian', eastLabelX, eastLabelY); 
            // Removed West (Post-Meridian) -> Post-Meridian
            ctx.fillText('Post-Meridian', westLabelX, westLabelY);

            // --- 5. Draw Legend (Top Left) ---
            
            const T_PBM_Deadline = T_Pause_sec > 0 ? -T_Pause_sec : null;
            
            const legendItems = [
                { 
                    // Reverted color to blue
                    label: 'Calculated Flip Start', 
                    time: t_FlipStart, 
                    color: '#3b82f6', 
                    isDashed: true, 
                    thickness: 2,  
                    isFocus: true 
                },
                { 
                    // Changed T1 color to red
                    label: 'Minutes After Meridian (T1)', 
                    time: T1_sec, 
                    color: '#ef4444', 
                    isDashed: false, 
                    thickness: 2, 
                    condition: T1_sec > 0 
                },
                { 
                    label: 'Max. Minutes After Meridian (T2)', 
                    time: T2_sec_software, 
                    color: '#3b82f6', 
                    isDashed: false, 
                    thickness: 2, 
                    condition: T2_sec_software > 0 
                },
                { 
                    label: 'Max. Mount Tracking Limit', 
                    time: T_MountLimit_sec, 
                    color: '#f87171', 
                    isDashed: false, 
                    thickness: 3, 
                    condition: T_MountLimit_sec > 0 
                },
                { 
                    // Changed PBM color to red
                    label: 'Pause before meridian (PBM)', 
                    time: T_PBM_Deadline, 
                    color: '#ef4444', 
                    isDashed: false, 
                    thickness: 2, 
                    condition: T_Pause_sec > 0 
                },
            ].filter(item => item.condition === undefined || item.condition);

            const legendX = 20;
            let legendY = 30;
            const lineHeight = 16; 
            const swatchSize = 10; 
            const textOffset = 15; 
            
            ctx.fillStyle = '#9ca3af'; 
            ctx.font = '12px Inter, sans-serif'; 
            ctx.textAlign = 'left';

            // Draw Legend Header
            ctx.fillStyle = '#f3f4f6';
            ctx.font = 'bold 14px Inter, sans-serif'; 
            ctx.fillText('Key Timing Points', legendX, legendY);
            legendY += lineHeight + 5;
            
            ctx.font = '12px Inter, sans-serif'; 

            legendItems.forEach(item => {
                ctx.strokeStyle = item.color; 
                ctx.fillStyle = item.color;
                
                // Draw Color Swatch (a short line segment)
                ctx.setLineDash(item.isDashed ? [3, 3] : []);
                ctx.lineWidth = item.thickness;
                ctx.beginPath();
                ctx.moveTo(legendX, legendY - swatchSize / 2 + 2); 
                ctx.lineTo(legendX + swatchSize, legendY - swatchSize / 2 + 2); 
                ctx.stroke();

                // Draw Text
                const timeString = formatTime(item.time);
                ctx.fillStyle = item.color;
                ctx.fillText(`${item.label}: ${timeString}`, legendX + textOffset, legendY);
                
                legendY += lineHeight;
            });
            
            // Reset line dash for main drawing area if needed (though drawLine handles it)
            ctx.setLineDash([]);
        }
        
        // --- Utility Functions ---

        /**
         * Formats total seconds into [+/-]Xm Ys format, ensuring a sign is always shown for non-zero values.
         * @param {number} totalSeconds - Time in seconds (relative to Meridian).
         * @returns {string} Formatted time string (e.g., "+2m 00s" or "-0m 45s").
         */
        function formatTime(totalSeconds) {
            let sign = '';
            if (totalSeconds > 0) {
                sign = '+'; // Add '+' for positive times
            } else if (totalSeconds < 0) {
                sign = '-'; // Keep '-' for negative times
            }
            
            const absSeconds = Math.abs(totalSeconds);
            const totalMinutes = Math.floor(absSeconds / 60);
            const remainingSeconds = absSeconds % 60;

            const secPart = remainingSeconds.toFixed(0).padStart(2, '0');

            // Always show minutes and seconds for consistent time axis labeling.
            return `${sign}${totalMinutes}m ${secPart}s`; 
        }
        
        /**
         * Calculates the appropriate font size for a label to fit within a given width
         * @param {string} text - The text content
         * @param {number} containerWidth - Width of the container in pixels
         * @param {number} maxFontSize - Maximum font size in rem
         * @returns {number} Font size in rem
         */
        function calculateFontSize(text, containerWidth, maxFontSize = 2) {
            // Approximate character width ratio (characters per rem of font size)
            const charWidthRatio = 0.6; // Adjusted for bold font
            const padding = 20; // Padding on sides
            const availableWidth = containerWidth - padding;
            
            // Calculate what font size would fit
            const textLength = text.length;
            let fontSize = availableWidth / (textLength * charWidthRatio * 16); // 16px = 1rem
            
            // Constrain between min and max
            fontSize = Math.max(0.75, Math.min(maxFontSize, fontSize));
            
            return fontSize;
        }
        
        /**
         * Renders the static time axis, markers, and the draggable sub chain.
         */
        function renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec, T_Exposure, t_SubChainStart, T_Pause_sec) {
            const axisChart = document.getElementById('time-axis-chart');
            const axisWrapper = document.getElementById('time-axis-wrapper');
            
            if (!axisChart || !axisWrapper) return;

            // 1. Determine Scale and Span
            const inputsMaxTime = Math.max(
                Math.abs(T_Effective_Deadline), 
                Math.abs(T_MountLimit_sec), 
                Math.abs(t_StartLastExp - T_Exposure), // Use chain start time for left limit
                T_Pause_sec, // Ensure PBM zone is visible
                300
            ); 
            maxTime = inputsMaxTime + 120; // Add 2 minutes buffer on each side
            
            const timeSpan = maxTime * 2; 
            const containerWidth = axisChart.clientWidth || 800;
            const contentWidth = containerWidth * 0.95; 
            
            initialScaleFactor = contentWidth / timeSpan; // Fixed scale for static axis
            
            // Recenter the content slightly within the container
            axisWrapper.style.width = `${containerWidth}px`; 
            
            // Position of the meridian (t=0)
            const meridianPos = (maxTime * initialScaleFactor); 

            // Helper function to convert time to pixel position
            const timeToPos = (time) => ((time + maxTime) * initialScaleFactor);

            // --- Clear and Redraw Static Elements ---
            axisWrapper.innerHTML = '';
            
            // 2. Draw Red Axis Line
            const axisLine = document.createElement('div');
            axisLine.className = 'time-axis-line';
            axisWrapper.appendChild(axisLine);
            
            // 3. Render PBM Pause Zone
            if (T_Pause_sec > 0) {
                const T_PBM_Deadline = -T_Pause_sec;
                const pbmZoneStartPos = timeToPos(T_PBM_Deadline);
                const pbmZoneEndPos = timeToPos(0);
                const pbmZoneWidth = pbmZoneEndPos - pbmZoneStartPos;

                const pbmZone = document.createElement('div');
                pbmZone.className = 'pbm-zone';
                pbmZone.style.left = `${pbmZoneStartPos}px`;
                pbmZone.style.width = `${pbmZoneWidth}px`;
                
                // Add PBM zone label with dynamic sizing
                const pbmLabel = document.createElement('div');
                pbmLabel.className = 'zone-label';
                pbmLabel.style.color = '#f87171';
                pbmLabel.textContent = 'PBM';
                const pbmFontSize = calculateFontSize('PBM', pbmZoneWidth, 2.5);
                pbmLabel.style.fontSize = `${pbmFontSize}rem`;
                pbmZone.appendChild(pbmLabel);
                
                axisWrapper.appendChild(pbmZone);
            }

            // 3A. Render T1 Wait Zone (from Meridian to T1)
            if (T1_sec > 0) {
                const t1ZoneStartPos = timeToPos(0); // Meridian
                const t1ZoneEndPos = timeToPos(T1_sec);
                const t1ZoneWidth = t1ZoneEndPos - t1ZoneStartPos;

                const t1WaitZone = document.createElement('div');
                t1WaitZone.className = 't1-wait-zone';
                t1WaitZone.style.left = `${t1ZoneStartPos}px`;
                t1WaitZone.style.width = `${t1ZoneWidth}px`;
                
                // Add T1 zone label with dynamic sizing
                const t1Label = document.createElement('div');
                t1Label.className = 'zone-label';
                t1Label.style.color = '#f97316';
                t1Label.textContent = 'T1';
                const t1FontSize = calculateFontSize('T1', t1ZoneWidth, 2.5);
                t1Label.style.fontSize = `${t1FontSize}rem`;
                t1WaitZone.appendChild(t1Label);
                
                axisWrapper.appendChild(t1WaitZone);
            }

            // 4. Render FLIP ZONE
            if (T_Effective_Deadline >= T1_sec) {
                const flipZoneStartPos = timeToPos(T1_sec);
                const flipZoneEndPos = timeToPos(T_Effective_Deadline);
                const flipZoneWidth = flipZoneEndPos - flipZoneStartPos;

                const flipZone = document.createElement('div');
                flipZone.className = 'flip-zone';
                flipZone.style.left = `${flipZoneStartPos}px`;
                flipZone.style.width = `${flipZoneWidth}px`;
                
                // Add label above the zone - Updated to use + signs
                const zoneLabel = document.createElement('span');
                zoneLabel.className = 'flip-zone-label';
                zoneLabel.style.top = '10px'; 
                zoneLabel.innerHTML = `FLIP WINDOW (${formatTime(T1_sec)} to ${formatTime(T_Effective_Deadline)})`;

                flipZone.appendChild(zoneLabel);
                
                // Add T2 zone label with dynamic sizing (centered in flip zone)
                const t2Label = document.createElement('div');
                t2Label.className = 'zone-label';
                t2Label.style.color = '#3b82f6';
                t2Label.textContent = 'T2';
                const t2FontSize = calculateFontSize('T2', flipZoneWidth, 2.5);
                t2Label.style.fontSize = `${t2FontSize}rem`;
                flipZone.appendChild(t2Label);
                
                axisWrapper.appendChild(flipZone);
            }
            
            // 5. Draw Vertical Indicator Lines (Lines are drawn over zones)
            
            // Flip Start Line
            const flipLine = document.createElement('div');
            flipLine.className = 'flip-line';
            flipLine.style.left = `${timeToPos(t_FlipStart)}px`;
            axisWrapper.appendChild(flipLine);

            // Meridian Line
            const meridianLine = document.createElement('div');
            meridianLine.className = 'meridian-line';
            meridianLine.style.left = `${meridianPos}px`;
            axisWrapper.appendChild(meridianLine);

            // Mount Limit Line
            const mountLimitLine = document.createElement('div');
            mountLimitLine.className = 'mount-limit-line';
            mountLimitLine.style.left = `${timeToPos(T_MountLimit_sec)}px`;
            axisWrapper.appendChild(mountLimitLine);


            // 6. Marker data points (Labels for vertical lines)
            const timeMarkers = [
                { time: 0, label: 'Meridian', color: 'text-yellow-500', placement: 'label-meridian' },
                { time: T_MountLimit_sec, label: 'Mount Limit', color: 'text-red-400', placement: 'label-mount-limit' }, 
                { time: t_FlipStart, label: 'Flip Starts', color: 'text-blue-400', placement: 'flip-start-label-main' }, 
            ];
            
            timeMarkers.forEach(marker => {
                const markerTime = marker.time;
                const position = timeToPos(markerTime);
                
                // Skip markers that fall outside the main visual area
                if (position < 0 || position > containerWidth) return;
                
                const markerLabel = document.createElement('span');
                
                let labelText = marker.label;
                let placementClass = marker.placement;
                let textColorClass = marker.color;
                
                // Add time coordinate to labels, explicitly formatted with +/- sign
                if (marker.label !== 'Meridian') {
                    labelText += `<br/>(${formatTime(markerTime)})`;
                }

                markerLabel.className = `time-marker-label ${textColorClass} ${placementClass}`;
                markerLabel.style.left = `${position}px`;
                markerLabel.innerHTML = labelText;
                
                axisWrapper.appendChild(markerLabel);
            });
            
            // 7. Dynamic Sub Chain Generation
            const subWidth = T_Exposure * initialScaleFactor;

            // Find the start time of the specific sub that triggers the flip (t_StartLastExp)
            let currentSubEnd = t_StartLastExp;
            
            // Generate previous subs until they fall off the left side of the screen
            let i = 1;
            while (true) {
                const T_PrevSubStart = currentSubEnd - T_Exposure;
                const T_PrevSubEnd = currentSubEnd;
                const prevSubStartPos = timeToPos(T_PrevSubStart);

                if (prevSubStartPos < 0) { // Stop drawing if the sub starts off screen
                    break;
                }
                
                let subElement = document.createElement('div');
                subElement.className = 'sub-exposure previous-sub';
                subElement.style.left = `${prevSubStartPos}px`;
                subElement.style.width = `${subWidth}px`;
                subElement.textContent = `Sub N-${i}`;
                subElement.style.opacity = Math.max(0.1, 1 - (i * 0.2)); // Fade opacity further back
                
                axisWrapper.appendChild(subElement);

                currentSubEnd = T_PrevSubStart;
                i++;
            }

            // 8. Add the Draggable/Last Sub (The triggering sub)
            let lastSubElement = document.createElement('div');
            lastSubElement.id = 'last-sub-exposure';
            lastSubElement.className = 'sub-exposure';
            lastSubElement.style.left = `${timeToPos(t_StartLastExp)}px`;
            lastSubElement.style.width = `${subWidth}px`;
            lastSubElement.textContent = `${formatTime(T_Exposure)} (Last Sub)`; 
            lastSubElement.style.cursor = 'grab'; 

            axisWrapper.appendChild(lastSubElement);
            
            // 9. Add Last Sub Start Label (Always shown, dynamic position)
            const startLabel = document.createElement('span');
            startLabel.className = 'time-marker-label sub-start-label'; 
            startLabel.innerHTML = `Last Sub Start<br/>(${formatTime(t_StartLastExp)})`;
            startLabel.style.left = `${timeToPos(t_StartLastExp)}px`;
            axisWrapper.appendChild(startLabel);
            
            // 10. Add Conditional visual marker for actual stop point
            if (T_Pause_sec > 0) {
                 // Add a visual marker for the actual stop time (t_DowntimeStart)
                 const stopMarker = document.createElement('div');
                 stopMarker.className = 'actual-stop-marker';
                 stopMarker.style.left = `${timeToPos(t_DowntimeStart)}px`;
                 axisWrapper.appendChild(stopMarker);
            }

            // Re-apply drag listeners to the newly created element
            setupDrag();

            // Center the view on the Meridian initially
            axisChart.scrollLeft = meridianPos - (containerWidth / 2);
        }

        // --- Drag Handlers (Simplified and uses new Sub Logic) ---
        let subElement, axisChart;

        function handleMouseDown(e) {
            // Check if the actual last-sub-exposure element was clicked
            if (e.target.id !== 'last-sub-exposure') return;
            e.preventDefault();
            isDragging = true;
            e.target.style.cursor = 'grabbing';
            axisChart.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            const rect = axisChart.getBoundingClientRect();
            // Calculate mouse position relative to the axis chart content
            const mouseX = e.clientX - rect.left + axisChart.scrollLeft;

            const timeSpan = maxTime * 2;
            const containerWidth = axisChart.clientWidth || 800;
            const contentWidth = containerWidth * 0.95;
            const scaleFactor = contentWidth / timeSpan; 

            let T_Exposure = parseFloat(document.getElementById('t_exposure').value) || 1; 

            // Calculate time equivalent of the mouse X position (This is the desired START time)
            let t_cursor_start = (mouseX / scaleFactor) - maxTime;
            
            // Don't allow the sub START to go past T1 (left boundary of flip window)
            const T1_sec = (parseFloat(document.getElementById('t1').value) || 0) * 60;
            if (t_cursor_start > T1_sec) {
                t_cursor_start = T1_sec;
            }
            
            // Anchor the END of the sub, as this is the trigger point.
            let t_new_end = t_cursor_start + T_Exposure;
            
            t_SubEnd_Manual = t_new_end;
            calculateFlip(false); // Do not reset scale during drag
        }

        function handleMouseUp() {
            isDragging = false;
            // The sub element must be re-fetched as it was replaced in renderTimeAxis
            const currentSubElement = document.getElementById('last-sub-exposure');
            if (currentSubElement) {
                currentSubElement.style.cursor = 'grab';
            }
            axisChart.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            // Ensure final position is calculated and snapped after mouse up
            calculateFlip();
        }

        function setupDrag() {
            axisChart = document.getElementById('time-axis-chart');
            
            if (axisChart) {
                // Ensure handlers are only attached once to the chart container
                if (!axisChart.hasAttribute('data-listeners-attached')) {
                    // Use event delegation for mousedown on the axis wrapper
                    axisChart.addEventListener('mousedown', handleMouseDown);
                    axisChart.setAttribute('data-listeners-attached', 'true');
                }
            }
        }
        
        /**
         * Calculates the total downtime and generates the data points based on manual sub placement.
         * @param {boolean} [resetScale=true] - Recalculate maxTime and scale if true.
         */
        function calculateFlip(resetScale = true) {
            
            // 1. Get User Inputs
            const T1_min = parseFloat(document.getElementById('t1').value) || 0;
            const T2_min = parseFloat(document.getElementById('t2').value) || 0;
            const T_Pause_min = parseFloat(document.getElementById('t_pause').value) || 0;
            const T_MountLimit_min = parseFloat(document.getElementById('t_mount_limit').value) || 0; 
            const T_Exposure = parseFloat(document.getElementById('t_exposure').value) || 1; 
            const summaryElement = document.getElementById('summary');
            
            if (!summaryElement) return;

            // Convert to seconds
            const T1_sec = T1_min * 60;
            const T2_sec_software = T2_min * 60; 
            const T_MountLimit_sec = T_MountLimit_min * 60; 
            const T_Pause_sec = T_Pause_min * 60;
            
            // Set initial drag time if not yet set (on initial load)
            if (t_SubEnd_Manual === 420 && T_Exposure > 0) {
                 t_SubEnd_Manual = T_Exposure; 
            }
            
            const T_Effective_Deadline = Math.min(T2_sec_software, T_MountLimit_sec);

            let t_DowntimeStart = t_SubEnd_Manual; // Sub end time determined by drag/snap
            let scenarioDescription = "";

            // Calculate the start time of the *current* sub-exposure based on the end time
            let t_StartLastExp = t_DowntimeStart - T_Exposure; 
            
            let t_FlipStart = 0;
            let T_Wait = 0;
            
            // --- Core Flip Logic ---

            if (T_Pause_sec > 0) {
                 // SCENARIO 1: Pause Before Meridian (PBM) is active
                const T_PBM_Deadline = -T_Pause_sec;
                
                if (t_DowntimeStart > T_PBM_Deadline) {
                     // The sub sequence would cross the PBM point. Clamped to PBM.
                     t_DowntimeStart = T_PBM_Deadline; 
                     t_StartLastExp = t_DowntimeStart - T_Exposure;
                     scenarioDescription = `Sequence ends before PBM. Imaging pauses when sub finishes. (${formatTime(T_PBM_Deadline)}).`;
                } else {
                     scenarioDescription = `Sequence ends before PBM. Imaging pauses when sub finishes.`;
                }

                // Flip must still wait for T1
                t_FlipStart = T1_sec; 
                T_Wait = t_FlipStart - t_DowntimeStart;

            } else if (T1_sec < T_Effective_Deadline) { 
                // SCENARIO 2: Flip Window (T1 < Deadline) - Opportunistic Flip

                // Check if the current sub finishes after the T_Effective_Deadline (too late)
                if (t_DowntimeStart > T_Effective_Deadline) {
                    // Sub finished too late. Tracking must stop at T_Effective_Deadline.
                    t_DowntimeStart = T_Effective_Deadline;
                    t_StartLastExp = t_DowntimeStart - T_Exposure;
                    scenarioDescription = `<strong>DEADLINE CROSSED:</strong> Sequence crosses the effective deadline. Tracking is clamped to the deadline.`;
                }
                
                // Check if the sub finishes within the T1 to Deadline window
                if (t_DowntimeStart >= T1_sec && t_DowntimeStart <= T_Effective_Deadline) {
                    // Opportunistic Flip: Sub finished within the window, flip immediately after sub ends.
                    t_FlipStart = t_DowntimeStart;
                    scenarioDescription = `Sub finishes in the flip window. Flip starts immediately after sub ends.`;
                } else if (t_DowntimeStart < T1_sec) {
                    // Sub finished too early (before T1). Must wait for T1.
                    t_FlipStart = T1_sec;
                    scenarioDescription = `<strong>WAIT FOR T1:</strong> Sub finishes before T1. System waits for T1 to start flip.`;
                } else {
                    // Should be covered by DEADLINE CROSSED, but as a fallback
                    t_FlipStart = T_Effective_Deadline;
                }

                // T_Wait is always the difference between when the flip *starts* and when tracking *stopped*.
                T_Wait = Math.max(0, t_FlipStart - t_DowntimeStart);

            } else { 
                // SCENARIO 3: Fixed Time Flip (T1 >= Deadline or T1 = T2)
                
                if (t_DowntimeStart > T1_sec) {
                    // Sub finished too late (past T1 deadline)
                    t_DowntimeStart = T1_sec; 
                    t_StartLastExp = t_DowntimeStart - T_Exposure;
                    scenarioDescription = `<strong>FIXED CLAMPED:</strong> Sub finished late. Tracking must stop at the T1 deadline.`;
                } else {
                    scenarioDescription = `<strong>FIXED SAFE:</strong> Sub finished safely before T1. Tracking stops when sub finishes.`;
                }
                
                t_FlipStart = T1_sec; 
                T_Wait = t_FlipStart - t_DowntimeStart;
            }
            
            // Final calculation for Wait (must be 0 or positive)
            T_Wait = Math.max(0, T_Wait);
            
            // --- Final Calculations and Summary Output ---

            const T_PostFlip = SYSTEM_CONSTANTS.T_Slew;
            const time_meridian_to_resume = t_FlipStart + T_PostFlip; 
            const T_Downtime = T_Wait + T_PostFlip;
            
            // Update global maxTime for rendering/drag limits (for linear axis)
            const minTime = Math.min(0, t_StartLastExp, -T_Pause_sec) - 60; // Include PBM start time in minimum calculation
            const maxTimeCalc = Math.max(0, T_MountLimit_sec, time_meridian_to_resume) + 60; 
            maxTime = Math.max(Math.abs(minTime), Math.abs(maxTimeCalc)); 
            
            // --- Angular Diagram Specific Scale Calculations (Symmetrical) ---
            
            // 1. Determine the largest time value (in magnitude) on either side
            const maxTimeMagnitude = Math.max(
                T_Pause_sec, 
                T2_sec_software, 
                T_MountLimit_sec, 
                time_meridian_to_resume,
                300 // Set a minimum base scale of 5 minutes (300s)
            ); 

            // 2. Set both positive and negative max displays to this single, symmetrical max.
            const T_neg_max_display = maxTimeMagnitude; 
            const T_pos_max_display = maxTimeMagnitude; 
            
            
            // --- SNAP LOGIC (Handles visual transition and anchoring) ---
            const subElement = document.getElementById('last-sub-exposure');
            if (subElement && !isDragging) {
                const axisChart = document.getElementById('time-axis-chart');
                const containerWidth = axisChart.clientWidth || 800;
                const timeSpan = maxTime * 2; 
                const contentWidth = containerWidth * 0.95;
                const scaleFactor = contentWidth / timeSpan; 
                
                const subStartPos = (t_StartLastExp + maxTime) * scaleFactor;
                
                const currentSubStartPos = parseFloat(subElement.style.left.replace('px', '')) || 0;
                const snapThreshold = 1; 

                // If a change in position is detected, snap the visual element
                if (Math.abs(currentSubStartPos - subStartPos) > snapThreshold) {
                    // To prevent visible jumps, we can quickly hide/show on snap
                    subElement.style.transition = 'none';
                    subElement.style.left = `${subStartPos}px`;
                    subElement.style.width = `${T_Exposure * scaleFactor}px`; // Ensure width update is instant
                    
                    setTimeout(() => {
                        if (subElement) subElement.style.transition = 'left 0.3s ease-out, opacity 0.3s ease-in-out, width 0.1s';
                    }, 10); 
                } else {
                    // If no snap, ensure width is correct (e.g., if exposure changed while dragging)
                    subElement.style.width = `${T_Exposure * scaleFactor}px`;
                }
            }
            
            // Update the manual anchor point to match the calculated start time when not dragging
            if (!isDragging) {
                // Ensure the next drag starts from the snapped position's end time
                t_SubEnd_Manual = t_DowntimeStart; 
            }

            // ************ RENDER ANGULAR DIAGRAM ************
            // Passing the symmetrical max values
            renderAngularDiagram(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, T2_sec_software, T_MountLimit_sec, T_Pause_sec, T_neg_max_display, T_pos_max_display);

            // Re-render the UI, passing T_Pause_sec
            renderTimeAxis(t_DowntimeStart, t_FlipStart, T_Effective_Deadline, T1_sec, t_StartLastExp, T_MountLimit_sec, T_Exposure, t_StartLastExp - T_Exposure, T_Pause_sec);


            let summaryHTML = `
                <p><strong>Last Sub Start:</strong> <span class="font-mono text-base text-green-400">${formatTime(t_StartLastExp)}</span></p>
                <p><strong>Tracking Stopped At:</strong> <span class="font-mono text-base text-red-400">${formatTime(t_DowntimeStart)}</span></p>

                <hr class="my-3 border-gray-700">
                
                <p><strong>Effective Flip Deadline:</strong> <span class="font-mono text-base text-yellow-500">${formatTime(T_Effective_Deadline)}</span> (Min of T2: ${formatTime(T2_sec_software)} and Mount Limit: ${formatTime(T_MountLimit_sec)})</p>
                
                <hr class="my-3 border-gray-700">

                <p><strong>Flip Initiated At:</strong> <span class="font-mono text-lg text-blue-400">${formatTime(t_FlipStart)}</span></p>
                <p class="mt-2"><strong><span class="text-wait-orange">Pre-Flip Wait Time:</span></strong> <span class="font-mono text-wait-orange text-lg">${formatTime(T_Wait)}</span></p>
                
                <hr class="my-3 border-gray-700">

                <p class="mt-1 text-sm text-gray-400">Imaging Resumes (Time after meridian): <span class="font-mono">${formatTime(time_meridian_to_resume)}</span></p>
            `;
            summaryElement.innerHTML = summaryHTML;
            
            // Update scenario description in the new location
            const scenarioElement = document.getElementById('scenario-description');
            if (scenarioElement) {
                scenarioElement.innerHTML = scenarioDescription;
            }
        }

        // Initialize the calculation and event listeners on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial value for T_SubEnd_Manual to be T_Exposure (the first sub finishes at t=Exposure)
            t_SubEnd_Manual = parseFloat(document.getElementById('t_exposure').value) || 420;
            setupDrag();
            calculateFlip();
            // Recalculate on resize to maintain responsiveness
            window.addEventListener('resize', calculateFlip); 
        });
    </script>
</body>
</html>
